<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Barotrauma Reactor Control</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --panel-bg: #1a2a2a;
            --panel-border: #4a5a5a;
            --screen-bg: #0a1414;
            --text-color: #a0f0c0;
            --text-dark: #60a080;
            --gauge-bg: #101818;
            --gauge-border: #333;
            --needle-color: #ff4d4d;
            --accent-red: #ff3b3b;
            --accent-yellow: #f0d040;
            --accent-green: #33ff88;
            --accent-blue: #3b9eff;
            --button-off: #3d4c4c;
            --button-on: #ff4d4d;
        }

        body {
            font-family: 'Roboto Condensed', sans-serif;
            background-color: #050808;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
        }

        .reactor-panel {
            width: 100%;
            max-width: 1000px;
            background: linear-gradient(180deg, #283838, #182424);
            border: 2px solid var(--panel-border);
            border-radius: 15px;
            padding: 1rem;
            box-shadow: 0 0 30px rgba(0, 255, 200, 0.1), inset 0 0 10px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 2fr 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 1rem;
            grid-template-areas:
                "header header"
                "gauges status"
                "warnings warnings";
        }

        /* --- Header --- */
        .panel-header {
            grid-area: header;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .header-warnings { display: flex; gap: 0.5rem; }

        .warning-light {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            padding: 0.3rem 0.6rem;
            border: 1px solid #000;
            border-radius: 5px;
            background-color: var(--button-off);
            color: rgba(255,255,255,0.4);
            text-shadow: 1px 1px 2px #000;
            transition: all 0.2s;
        }
        .warning-light.active {
             background-color: var(--accent-red);
             color: #fff;
             box-shadow: 0 0 10px var(--accent-red);
        }

        .main-controls { display: flex; align-items: center; gap: 1rem; }
        .control-switch {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .switch-label { font-size: 0.7rem; text-transform: uppercase; color: var(--text-dark); }
        .switch {
            width: 50px;
            height: 25px;
            background: var(--button-off);
            border-radius: 25px;
            border: 1px solid #000;
            position: relative;
            cursor: pointer;
        }
        .switch-knob {
            position: absolute;
            width: 21px;
            height: 21px;
            background: #ccc;
            border-radius: 50%;
            top: 1px;
            left: 2px;
            transition: all 0.2s ease-in-out;
            box-shadow: inset 0 -2px 3px rgba(0,0,0,0.4);
        }
        .switch.on .switch-knob {
            left: 26px;
            background: var(--accent-green);
        }

        .power-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #000;
            background: var(--button-off);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 3px 5px rgba(0,0,0,0.5);
        }
        .power-button.on {
            background-color: var(--button-on);
            box-shadow: 0 0 15px var(--button-on);
        }
        .power-button-label { font-size: 0.7rem; color: var(--text-dark); }


        /* --- Gauges --- */
        .gauges-container { grid-area: gauges; display: flex; gap: 1rem; justify-content: space-around; }

        .gauge {
            width: 250px;
            height: 220px;
            background-color: var(--gauge-bg);
            border: 2px solid var(--gauge-border);
            border-radius: 10px;
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .gauge-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--text-color);
        }
        .gauge-body {
            position: relative;
            width: 200px;
            height: 100px;
            overflow: hidden;
        }
        .gauge-face {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 2px solid var(--gauge-border);
            position: absolute;
            top: 0;
            box-sizing: border-box;
        }
        
        .gauge-needle {
            position: absolute;
            width: 2px;
            height: 80px;
            background-color: var(--needle-color);
            bottom: 0px;
            left: 99px;
            transform-origin: bottom center;
            transition: transform 0.2s linear;
            z-index: 10;
        }
        .gauge-needle-hub {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #555;
            border-radius: 50%;
            bottom: -5px;
            left: 95px;
            z-index: 11;
        }
        .gauge-ticks {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        .tick-label {
            position: absolute;
            color: var(--text-color);
            font-size: 0.8rem;
            text-align: center;
        }
        .gauge-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 80%;
            height: 15px;
            background: #000;
            border: 1px solid var(--gauge-border);
            border-radius: 5px;
            outline: none;
            margin-top: 10px;
            cursor: pointer;
        }
        .gauge-slider:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        .gauge-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 25px;
            background: #999;
            border: 1px solid #333;
            border-radius: 3px;
            cursor: pointer;
            margin-top: -5px;
        }
        .gauge-slider::-moz-range-thumb {
            width: 15px;
            height: 25px;
            background: #999;
            border: 1px solid #333;
            border-radius: 3px;
            cursor: pointer;
        }


        /* --- Status Display --- */
        .status-display {
            grid-area: status;
            display: flex;
            flex-direction: column;
            background: var(--screen-bg);
            border: 2px solid var(--gauge-border);
            border-radius: 10px;
            padding: 1rem;
        }
        .power-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
        }
        #graph-wrapper {
            flex-grow: 1;
            display: flex;
            margin: 0.5rem 0;
            gap: 0.5rem;
        }
        .graph-scale {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 0.6rem;
            color: var(--text-dark);
        }
        .graph-scale.left { text-align: left; color: var(--accent-yellow); }
        .graph-scale.right { text-align: right; }
        
        #graph-container {
            flex-grow: 1;
            background: #000;
            border-radius: 5px;
        }
        #history-graph {
            width: 100%;
            height: 100%;
        }


        /* --- Warning Lights --- */
        .warnings-grid {
            grid-area: warnings;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            background: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 8px;
        }
        .status-light {
            background-color: #111;
            border: 2px solid #000;
            color: #555;
            text-align: center;
            padding: 0.5rem;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        .status-light.active.temp-low { background-color: var(--accent-blue); color: #fff; box-shadow: 0 0 10px var(--accent-blue); }
        .status-light.active.overheat { background-color: var(--accent-yellow); color: #000; box-shadow: 0 0 10px var(--accent-yellow); }
        .status-light.active.output-low, .status-light.active.output-high { background-color: var(--accent-yellow); color: #000; box-shadow: 0 0 10px var(--accent-yellow); }
        .status-light.active.fuel-low { background-color: var(--accent-yellow); color: #000; box-shadow: 0 0 10px var(--accent-yellow); }
        .status-light.active.fuel-out { background-color: var(--accent-red); color: #fff; box-shadow: 0 0 10px var(--accent-red); }
        .status-light.active.meltdown { background-color: var(--accent-red); color: #fff; box-shadow: 0 0 20px #ff0000, inset 0 0 10px #fff; animation: blink 0.5s infinite; }
        .status-light.active.scram { background-color: var(--accent-red); color: #fff; box-shadow: 0 0 10px var(--accent-red); }

        @keyframes blink {
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>

    <div class="reactor-panel">
        <!-- Header -->
        <div class="panel-header">
            <div class="header-warnings">
                <div id="critical-heat" class="warning-light">CRITICAL HEAT</div>
                <div id="critical-output" class="warning-light">CRITICAL OUTPUT</div>
            </div>
            <div class="main-controls">
                <div class="control-switch">
                    <span class="switch-label">AUTOMATIC CONTROL</span>
                    <div id="auto-control-switch" class="switch">
                        <div class="switch-knob"></div>
                    </div>
                </div>
                 <div class="control-switch">
                    <span class="power-button-label">POWER</span>
                    <div id="power-button" class="power-button"></div>
                </div>
            </div>
        </div>

        <!-- Gauges -->
        <div class="gauges-container">
            <div class="gauge">
                <div class="gauge-title">FISSION RATE</div>
                <div id="fission-rate-gauge" class="gauge-body">
                    <div class="gauge-face"></div>
                    <div class="gauge-ticks"></div>
                    <div class="gauge-needle"></div>
                    <div class="gauge-needle-hub"></div>
                </div>
                <div class="gauge-value-display"><span id="fission-rate-value">0</span>%</div>
                <input type="range" id="fission-rate-slider" class="gauge-slider" min="0" max="100" step="1" value="0">
            </div>
            <div class="gauge">
                <div class="gauge-title">TURBINE OUTPUT</div>
                <div id="turbine-output-gauge" class="gauge-body">
                    <div class="gauge-face"></div>
                    <div class="gauge-ticks"></div>
                    <div class="gauge-needle"></div>
                    <div class="gauge-needle-hub"></div>
                </div>
                 <div class="gauge-value-display"><span id="turbine-output-value">0</span>%</div>
                 <input type="range" id="turbine-output-slider" class="gauge-slider" min="0" max="100" step="1" value="0">
            </div>
        </div>

        <!-- Status -->
        <div class="status-display">
            <div class="power-info">
                <span class="label" style="color: var(--accent-blue);">LOAD:</span>
                <span id="power-load">1005 KW</span>
            </div>
            <div id="graph-wrapper">
                 <div id="temp-scale" class="graph-scale left"></div>
                 <div id="graph-container">
                    <canvas id="history-graph"></canvas>
                 </div>
                 <div id="power-scale" class="graph-scale right"></div>
            </div>
            <div class="power-info mt-2">
                <span class="label" style="color: var(--accent-green);">OUTPUT:</span>
                <span id="power-output">0 KW</span>
            </div>
        </div>

        <!-- Warning Lights -->
        <div class="warnings-grid">
            <div id="status-temp-low" class="status-light">TEMP LOW</div>
            <div id="status-output-low" class="status-light">OUTPUT LOW</div>
            <div id="status-fuel-low" class="status-light">FUEL LOW</div>
            <div id="status-meltdown" class="status-light">MELTDOWN</div>
            <div id="status-overheat" class="status-light">OVERHEAT</div>
            <div id="status-output-high" class="status-light">OUTPUT HIGH</div>
            <div id="status-fuel-out" class="status-light">FUEL OUT</div>
            <div id="status-scram" class="status-light">SCRAM</div>
        </div>
    </div>

    <script type="module">
        // --- The Reactor Simulation Class ---
        const ReactorStatus = {
            None: 0, TempLow: 1 << 0, Overheat: 1 << 1, OutputLow: 1 << 2, OutputHigh: 1 << 3,
            FuelLow: 1 << 4, FuelOut: 1 << 5, Meltdown: 1 << 6, Scram: 1 << 7,
        };

        class Reactor {
            state;
            // --- Tuned Physics Constants ---
            MAX_TEMP = 10000;
            MAX_POWER_OUTPUT = 5000;
            MELTDOWN_TEMP = 9000;
            OVERHEAT_TEMP = 6000;
            LOW_TEMP = 2000;
            OPTIMAL_TEMP = 5000; // Target for auto-controller
            FUEL_CONSUMPTION_RATE = 0.05;
            HEAT_GENERATION_RATE = 1000; // Retuned for stable output
            AMBIENT_TEMP_DISSIPATION = 0.05;
            TURBINE_POWER_FACTOR = 1.2;
            LOW_FUEL_THRESHOLD = 20;

            constructor() {
                // --- Calculate initial stable state for 1000 KW load ---
                const initialLoad = 1000;
                const initialTemp = this.OPTIMAL_TEMP;
                const initialTurbine = initialLoad / (initialTemp / 100 * (initialTemp/this.OVERHEAT_TEMP) * this.TURBINE_POWER_FACTOR);
                const heatConsumed = (initialLoad / this.TURBINE_POWER_FACTOR) + (initialTemp * this.AMBIENT_TEMP_DISSIPATION);
                const initialFission = (heatConsumed * 100) / this.HEAT_GENERATION_RATE;

                this.state = {
                    isPoweredOn: true,
                    isAutoControl: true,
                    temperature: initialTemp,
                    fissionRate: initialFission,
                    turbineOutput: initialTurbine,
                    powerOutput: initialLoad,
                    powerLoad: initialLoad,
                    fuelRod: { condition: 100 },
                    status: ReactorStatus.None,
                };
            }

            update(deltaTime) {
                if (!this.state.isPoweredOn || this.hasStatus(ReactorStatus.Scram)) {
                    this.shutdownCooling(deltaTime); this.updateStatusFlags(); return;
                }
                if (this.state.isAutoControl) this.runAutoControl();
                let heatGenerated = 0;
                if (this.state.fuelRod && this.state.fuelRod.condition > 0) {
                    heatGenerated = (this.state.fissionRate / 100) * this.HEAT_GENERATION_RATE;
                    this.state.temperature += heatGenerated * deltaTime;
                    const fuelConsumed = (this.state.fissionRate / 100) * this.FUEL_CONSUMPTION_RATE * deltaTime;
                    this.state.fuelRod.condition = Math.max(0, this.state.fuelRod.condition - fuelConsumed);
                }
                const tempEfficiency = Math.min(1, this.state.temperature / this.OVERHEAT_TEMP);
                const potentialPower = this.state.temperature * (this.state.turbineOutput / 100) * tempEfficiency;
                this.state.powerOutput = Math.min(this.MAX_POWER_OUTPUT, potentialPower * this.TURBINE_POWER_FACTOR);
                const heatConsumedByTurbine = this.state.powerOutput / this.TURBINE_POWER_FACTOR;
                const ambientCooling = this.state.temperature * this.AMBIENT_TEMP_DISSIPATION;
                this.state.temperature -= (heatConsumedByTurbine + ambientCooling) * deltaTime;
                this.state.temperature = Math.max(0, this.state.temperature);
                this.updateStatusFlags();
            }

            shutdownCooling(deltaTime) {
                this.state.fissionRate = 0;
                const tempEfficiency = Math.min(1, this.state.temperature / this.OVERHEAT_TEMP);
                const potentialPower = this.state.temperature * (this.state.turbineOutput / 100) * tempEfficiency;
                this.state.powerOutput = Math.min(this.MAX_POWER_OUTPUT, potentialPower * this.TURBINE_POWER_FACTOR);
                const heatConsumedByTurbine = this.state.powerOutput / this.TURBINE_POWER_FACTOR;
                const ambientCooling = this.state.temperature * (this.AMBIENT_TEMP_DISSIPATION * 2);
                this.state.temperature -= (heatConsumedByTurbine + ambientCooling) * deltaTime;
                this.state.temperature = Math.max(0, this.state.temperature);
                if (this.state.temperature <= 1) this.state.powerOutput = 0;
            }

            runAutoControl() {
                const powerError = this.state.powerLoad - this.state.powerOutput;
                this.state.turbineOutput += powerError * 0.01;
                const tempError = this.OPTIMAL_TEMP - this.state.temperature;
                this.state.fissionRate += tempError * 0.002;
                this.state.fissionRate = Math.max(0, Math.min(100, this.state.fissionRate));
                this.state.turbineOutput = Math.max(0, Math.min(100, this.state.turbineOutput));
            }

            updateStatusFlags() {
                this.state.status = ReactorStatus.None;
                if (this.state.temperature >= this.MELTDOWN_TEMP) this.addStatus(ReactorStatus.Meltdown);
                else if (this.state.temperature >= this.OVERHEAT_TEMP) this.addStatus(ReactorStatus.Overheat);
                else if (this.state.temperature < this.LOW_TEMP && this.state.isPoweredOn && this.state.powerOutput > 0) this.addStatus(ReactorStatus.TempLow);
                const powerDifference = this.state.powerOutput - this.state.powerLoad;
                if (powerDifference > this.state.powerLoad * 0.2 && this.state.powerLoad > 100) this.addStatus(ReactorStatus.OutputHigh);
                if (powerDifference < -this.state.powerLoad * 0.2 && this.state.powerLoad > 100) this.addStatus(ReactorStatus.OutputLow);
                if (!this.state.fuelRod || this.state.fuelRod.condition <= 0) {
                    this.addStatus(ReactorStatus.FuelOut); this.state.fuelRod = null;
                } else if (this.state.fuelRod.condition < this.LOW_FUEL_THRESHOLD) {
                    this.addStatus(ReactorStatus.FuelLow);
                }
            }
            powerOn = () => { if (!this.state.isPoweredOn) { this.state.isPoweredOn = true; if (this.hasStatus(ReactorStatus.Scram)) this.state.status &= ~ReactorStatus.Scram; }};
            powerOff = () => { if (this.state.isPoweredOn) { this.state.isPoweredOn = false; }};
            toggleAutoControl = () => this.state.isAutoControl = !this.state.isAutoControl;
            setFissionRate = (rate) => { if (!this.state.isAutoControl) this.state.fissionRate = Math.max(0, Math.min(100, parseFloat(rate))); };
            setTurbineOutput = (rate) => { if (!this.state.isAutoControl) this.state.turbineOutput = Math.max(0, Math.min(100, parseFloat(rate))); };
            setPowerLoad = (load) => this.state.powerLoad = Math.max(0, load);
            scram = () => { this.addStatus(ReactorStatus.Scram); this.state.isPoweredOn = false; };
            getState = () => this.state;
            addStatus = (status) => this.state.status |= status;
            hasStatus = (status) => (this.state.status & status) === status;
        }

        // --- UI Controller ---
        document.addEventListener('DOMContentLoaded', () => {
            const reactor = new Reactor();

            const ui = {
                powerButton: document.getElementById('power-button'),
                autoSwitch: document.getElementById('auto-control-switch'),
                fissionNeedle: document.querySelector('#fission-rate-gauge .gauge-needle'),
                fissionValue: document.getElementById('fission-rate-value'),
                fissionSlider: document.getElementById('fission-rate-slider'),
                turbineNeedle: document.querySelector('#turbine-output-gauge .gauge-needle'),
                turbineValue: document.getElementById('turbine-output-value'),
                turbineSlider: document.getElementById('turbine-output-slider'),
                powerLoad: document.getElementById('power-load'),
                powerOutput: document.getElementById('power-output'),
                graphCanvas: document.getElementById('history-graph'),
                tempScale: document.getElementById('temp-scale'),
                powerScale: document.getElementById('power-scale'),
                criticalHeat: document.getElementById('critical-heat'),
                criticalOutput: document.getElementById('critical-output'),
                statusLights: {
                    [ReactorStatus.TempLow]: document.getElementById('status-temp-low'),
                    [ReactorStatus.Overheat]: document.getElementById('status-overheat'),
                    [ReactorStatus.OutputLow]: document.getElementById('status-output-low'),
                    [ReactorStatus.OutputHigh]: document.getElementById('status-output-high'),
                    [ReactorStatus.FuelLow]: document.getElementById('status-fuel-low'),
                    [ReactorStatus.FuelOut]: document.getElementById('status-fuel-out'),
                    [ReactorStatus.Meltdown]: document.getElementById('status-meltdown'),
                    [ReactorStatus.Scram]: document.getElementById('status-scram'),
                }
            };

            const graphCtx = ui.graphCanvas.getContext('2d');
            let graphHistory = [];
            const MAX_HISTORY = 200;

            function createTicks(gaugeBody) {
                const ticksContainer = gaugeBody.querySelector('.gauge-ticks');
                ticksContainer.innerHTML = '';
                for (let i = 0; i <= 10; i++) {
                    const angle = -90 + (i * 18);
                    const tickWrapper = document.createElement('div');
                    tickWrapper.style.cssText = `position:absolute; left:0; top:0; width:200px; height:100px; transform: rotate(${angle}deg); transform-origin: 100px 100px;`;
                    const tick = document.createElement('div');
                    const isMajor = i % 5 === 0;
                    tick.style.cssText = `position:absolute; left:99.5px; top:0; width:1px; height:${isMajor ? '10px' : '5px'}; background-color: ${isMajor ? 'var(--text-color)' : 'var(--text-dark)'};`;
                    tickWrapper.appendChild(tick);
                    ticksContainer.appendChild(tickWrapper);
                    if (i % 2 === 0) {
                       const label = document.createElement('div');
                       label.className = 'tick-label';
                       label.textContent = i * 10;
                       const labelAngleRad = angle * (Math.PI / 180);
                       const radius = 85;
                       const x = 100 + radius * Math.sin(labelAngleRad);
                       const y = 100 - radius * Math.cos(labelAngleRad);
                       label.style.left = `${x}px`;
                       label.style.top = `${y}px`;
                       label.style.transform = 'translate(-50%, -50%)';
                       ticksContainer.appendChild(label);
                    }
                }
            }
            createTicks(document.getElementById('fission-rate-gauge'));
            createTicks(document.getElementById('turbine-output-gauge'));

            function populateScales() {
                const tempScaleDiv = ui.tempScale;
                const powerScaleDiv = ui.powerScale;
                tempScaleDiv.innerHTML = '';
                powerScaleDiv.innerHTML = '';
                
                const numLabels = 5;
                for(let i = 0; i < numLabels; i++) {
                    // Temperature Scale (left)
                    const tempLabel = document.createElement('div');
                    const tempValue = reactor.MAX_TEMP * (1 - (i / (numLabels - 1)));
                    tempLabel.textContent = `${(tempValue/1000).toFixed(0)}k°C`;
                    tempScaleDiv.appendChild(tempLabel);

                    // Power Scale (right)
                    const powerLabel = document.createElement('div');
                    const powerValue = reactor.MAX_POWER_OUTPUT * (1 - (i / (numLabels - 1)));
                    powerLabel.textContent = `${(powerValue/1000).toFixed(1)}kW`;
                    powerScaleDiv.appendChild(powerLabel);
                }
            }
            populateScales();


            ui.powerButton.addEventListener('click', () => reactor.getState().isPoweredOn ? reactor.powerOff() : reactor.powerOn());
            ui.autoSwitch.addEventListener('click', () => reactor.toggleAutoControl());
            ui.fissionSlider.addEventListener('input', (e) => reactor.setFissionRate(e.target.value));
            ui.turbineSlider.addEventListener('input', (e) => reactor.setTurbineOutput(e.target.value));
            ui.statusLights[ReactorStatus.Meltdown].addEventListener('click', () => reactor.scram());

            let lastTime = 0;
            function gameLoop(currentTime) {
                if (!lastTime) lastTime = currentTime;
                const deltaTime = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                const currentLoad = reactor.getState().powerLoad;
                const loadDelta = Math.floor(Math.random() * 25) - 12;
                let newLoad = currentLoad + loadDelta;
                if (newLoad > 3000) newLoad = 3000;
                if (newLoad < 800) newLoad = 1000;
                reactor.setPowerLoad(newLoad);

                reactor.update(deltaTime || 0);
                updateUI(reactor.getState());
                drawGraph();
                requestAnimationFrame(gameLoop);
            }

            function updateUI(state) {
                ui.powerButton.classList.toggle('on', state.isPoweredOn);
                ui.autoSwitch.classList.toggle('on', state.isAutoControl);

                ui.fissionNeedle.style.transform = `rotate(${-90 + state.fissionRate * 1.8}deg)`;
                ui.fissionValue.textContent = state.fissionRate.toFixed(0);
                ui.fissionSlider.value = state.fissionRate;
                ui.fissionSlider.disabled = state.isAutoControl;
                
                ui.turbineNeedle.style.transform = `rotate(${-90 + state.turbineOutput * 1.8}deg)`;
                ui.turbineValue.textContent = state.turbineOutput.toFixed(0);
                ui.turbineSlider.value = state.turbineOutput;
                ui.turbineSlider.disabled = state.isAutoControl;

                ui.powerLoad.textContent = `${state.powerLoad.toFixed(0)} KW`;
                ui.powerOutput.textContent = `${state.powerOutput.toFixed(0)} KW`;

                for (const [statusEnum, element] of Object.entries(ui.statusLights)) {
                    element.classList.toggle('active', reactor.hasStatus(parseInt(statusEnum)));
                }
                
                const isCritOutput = reactor.hasStatus(ReactorStatus.OutputLow) || reactor.hasStatus(ReactorStatus.OutputHigh);
                const isCritHeat = reactor.hasStatus(ReactorStatus.Overheat) || reactor.hasStatus(ReactorStatus.Meltdown);
                ui.criticalHeat.classList.toggle('active', isCritHeat);
                ui.criticalOutput.classList.toggle('active', isCritOutput);

                graphHistory.push({
                    temp: state.temperature,
                    load: state.powerLoad,
                    output: state.powerOutput
                });
                if (graphHistory.length > MAX_HISTORY) {
                    graphHistory.shift();
                }
            }
            
            function drawGraph() {
                const canvas = ui.graphCanvas;
                const ctx = graphCtx;
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (graphHistory.length < 2) return;

                function drawLine(dataKey, color, maxVal) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    for (let i = 0; i < graphHistory.length; i++) {
                        const point = graphHistory[i];
                        const x = (i / (MAX_HISTORY - 1)) * canvas.width;
                        const y = canvas.height - (point[dataKey] / maxVal) * canvas.height;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                drawLine('temp', 'red', reactor.MAX_TEMP);
                drawLine('load', 'blue', reactor.MAX_POWER_OUTPUT);
                drawLine('output', 'green', reactor.MAX_POWER_OUTPUT);
            }
            
            // Initial UI sync
            updateUI(reactor.getState());
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
